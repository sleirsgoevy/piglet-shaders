//unk = unknown, meaningful
//cbz = unknown, can be zero

typedef uint32_t rel_ptr_t; //ptr = rel_ptr + (char*)&rel_ptr

struct shdr
{
    uint64_t cbz00;
    uint64_t cbz08;
    uint64_t footer_offset_10;
    uint64_t zero18;
    uint32_t zero20;
    char magic24[4]; // "Shdr"
    uint64_t cbz28;
    uint32_t zero30;
    uint16_t size34; //=footer_offset_10-entry3c-0x10
    uint16_t cbz36;
    uint32_t zero38;
    uint32_t entry3c; //gpu code starts at entry3c+0x34
    uint32_t cbz40;
    uint16_t nreg44; //nvec = (nreg44%64+1)*4, nscal = (nreg44/64+1)*8
    uint16_t cbz46;
    uint64_t m0_init_reg_48; //must be %4==0, the register for initializing M0 is s[m0_init_reg_48/2]
    uint32_t always4_50; //4, setting to 0 disables shader, setting to nonzero causes visual artifacts (black output), setting to 12 causes crash
    uint32_t shader_type_54; //0 for vertex, 2 for fragment
    uint8_t unk58; //1 for vertex, 2->0 for fragment. often 2 for vertex too
    uint8_t cbz59;
    uint16_t cbz5a;
    uint32_t has_coords_5c; //if true, coords for interpolation are in v[0:1]
    uint32_t shader_type_60; //0x20017 for vertex, 0 for fragment
    uint32_t cbz64;
    uint32_t channel_mask_68; //R=1, G=2, B=4, A=8, 0x20400 for vertex shader
    uint32_t cbz6c;
    uint32_t gcn_bytecode[]; //at entry3c+0x34
};

//footer_offset_10=0xac, struct offset 0xa8
struct orb_shdr
{
    uint16_t cbz_f0;
    uint16_t cbz_f2;
    uint16_t unk_f4;
    uint16_t uniform_ptr_reg_f6; //s[uniform_ptr_reg_f6:uniform_ptr_reg_f6+3]
    uint16_t unk_f8;
    uint16_t sampler_ptr_reg_fa; //s[sampler_ptr_reg_fa:sampler_ptr_reg_fa+3]
    uint32_t buffer_source_fc; //if not 2, reads clear color instead of uniforms
    uint32_t cbz00;
    uint32_t cbz04;
    char magic08[8]; // "OrbShdr"
    uint32_t cbz10;
    uint8_t unk14[2]; //2 1, changing causes artifacts
    uint16_t cbz16;
    uint64_t cbz18;
    uint32_t cbz20;
    uint32_t number_of_sampler_uniforms_24;
    uint32_t cnt28; //+32 to program size
    uint32_t number_of_uniforms_2c;
    uint32_t number_of_samplers_30;
    uint8_t number_of_inputs_34;
    uint8_t number_of_outputs_35;
    uint8_t cnt36; //+16 to program size
    uint8_t cbz37;
    uint32_t cnt38; //+1 to program size
    uint32_t strings_size_3c; //+1 to program size
    struct orb_shdr_sampler_uniform
    {
        uint32_t index00;
        uint32_t zero04;
        uint8_t unk08; //always 2
        uint8_t cbz09;
        uint8_t cbz0a;
        uint8_t zero0b;
        uint32_t zero0c;
        uint32_t zero10;
        rel_ptr_t name14;
    } sampler_uniforms[cnt24-1];
    uint32_t cbz40; //assumes cnt24=1
    uint32_t size_of_uniform_space_44;
    uint16_t unk48; //changing causes uniform not found
    uint16_t cbz4a;
    uint32_t number_of_uniforms_4c; //is it?
    uint32_t zero50;
    rel_ptr_t global_cb_s_54; // "__GLOBAL_CB__"
    struct orb_shdr_uniform
    {
        uint8_t type00; //TODO: enum table
        uint8_t is_enabled_01;
        uint8_t zero02;
        uint8_t cbz03;
        uint32_t offset04; //some offset or size
        uint32_t size08; //xxx: error message says its offset
        uint32_t cbz0c;
        uint64_t cbz10;
        uint32_t cbz18;
        rel_ptr_t name_offset_1c;
        rel_ptr_t no_name_s_20; // "(no_name)"
    } uniforms[number_of_uniforms_2c];
    struct orb_shdr_sampler
    {
        uint64_t zero00;
        uint32_t index08;
        rel_ptr_t name0c;
    } samplers[number_of_samplers_30];
    struct orb_shdr_attrib
    {
        uint8_t type00; //TODO: enum table
        uint8_t marker01;
        uint8_t zero02;
        uint8_t index03;
        uint32_t zero04;
        rel_ptr_t name08;
        rel_ptr_t name_caps_0c;
    } attribs[number_of_inputs_34+number_of_outputs_35];
    char strings[];
};
